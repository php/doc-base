<?xml version="1.0" encoding="iso-8859-7"?>
<!-- $Revision: 1.1 $ -->
<!-- EN-Revision: 1.34 Maintainer: daphnie Status: ready -->
 <chapter id="functions">
  <title>Συναρτήσεις</title>

  <sect1 id="functions.user-defined">
   <title>Συναρτήσεις οριζόμενες από το χρήστη</title>
 
   <para>
    Μια συνάρτηση μπορεί να οριστεί χρησιμοποιώντας την ακόλουθη σύνταξη:
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
function foo ($arg_1, $arg_2, ..., $arg_n)
{
    echo "Example function.\n";
    return $retval;
}
]]>
     </programlisting>
    </informalexample>
   </para>
   
   <!--
    
    status of func(const $param) ?
    zend doesn't care at all whether or not you specify it.
    I've never seen it before... what's its use? (or was...)
    
    -->
     
   <simpara>
    Οποιοσδήποτε έγκυρος PHP κώδικας μπορεί να εμφανιστεί σε μια συνάρτηση, ακόμη και σε άλλες
    συναρτήσεις και σε ορισμούς <link linkend="keyword.class">κλάσεων (class)</link>
    .
   </simpara>
   <simpara>
    Στην PHP 3, οι συναρτήσεις πρέπει να ορίζονται πριν γίνει κάποια αναφορά σ'αυτές. Τέτοια
    απάιτηση δεν υπάρχει στην PHP 4. <emphasis>Εκτός</emphasis> αν
    η συνάρτηση  ορίζεται σε μια υπόθεση όπως μπορείτε να δείτε στα παρακάτω δύο
    παραδείγματα.
   </simpara>
   <para>
    Όταν μια συνάρτηση ορίζεται με υποθετικό τρόπο όπως στα δυο παρακάτω
    παραδείγματα ο ορισμός της πρέπει να <emphasis>προηγείται</emphasis>
    από το σημείο στο οποίο καλείται.
    <example>
     <title>Conditional functions</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* We can't call foo() from here 
   since it doesn't exist yet,
   but we can call bar() */

bar();

if ($makefoo) {
  function foo ()
  {
    echo "I don't exist until program execution reaches me.\n";
  }
}

/* Now we can safely call foo()
   since $makefoo evaluated to true */

if ($makefoo) foo();

function bar() 
{
  echo "I exist immediately upon program start.\n";
}

?>
]]>
     </programlisting>
    </example>
    <example>
     <title>Functions within functions</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() 
{
  function bar() 
  {
    echo "I don't exist until foo() is called.\n";
  }
}

/* We can't call bar() yet
   since it doesn't exist. */

foo();

/* Now we can call bar(),
   foo()'s processesing has
   made it accessable. */

bar();

?>  
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Η PHP δεν υποστηρίζει υπερφόρτωση συναρτήσεων, ούτε είναι δυνατό να
    υπάρχουν μη-καθορισμένες ή ξανά-καθορισμένες συναρτήσεις που έχουν δηλωθεί προηγουμένως.
   </simpara>
   <note>
    <simpara>
     Τα ονόματα των συναρτήσεων είναι case-insensitive, αλλά γενικά είναι καλή τακτική
     να καλούμε τις συναρτήσεις όπως εμφανίζονται στη δήλωση τους.
    </simpara>
   </note>   
   <simpara>
    Η PHP 3 δεν υποστηρίζει μεταβλητές αριθμών ή παραμέτρους στις συναρτήσεις,
    παρόλο που οι προκαθορισμένες παράμετροι υποστηρίζονται (βλέπε <link
    linkend="functions.arguments.default">Τιμές προκαθορισμένων
    παραμέτρων</link> για περισσότερες πληροφορίες). Η PHP 4 υποστηρίζει και τα δυο: βλέπε <link
    linkend="functions.variable-arg-list">Λίστες μεταβλητού μήκους παραμέτρων
    </link> και τις αναφορές στις συναρτήσεις για  τις
    <function>func_num_args</function>,
    <function>func_get_arg</function>, και
    <function>func_get_args</function> για περισσότερες πληροφορίες.
   </simpara>

  </sect1>
 
  <sect1 id="functions.arguments">
   <title>Παράμετροι συναρτήσεων</title>
 
   <simpara>
    Η πληροφορία μπορεί να περάσει στις συναρτήσεις διαμέσου της λίστας παραμέτρων,
    η οποία είναι μια λίστα μεταβλητών ή/και σταθερών που διαχωρίζονται με κόμματα.
   </simpara> 
   <para>
     Η PHP υποστηρίζει το πέρασμα των παραμέτρων με τιμή (το προκαθορισμένο), <link
     linkend="functions.arguments.by-reference">πέρασμα με
     αναφορά</link>, και <link
     linkend="functions.arguments.default">προκαθορισμένες τιμές
     παραμέτρων</link>. Οι λίστες παραμέτρων μεταβλητού μήκους υποστηρίζονται μόνο από
     την PHP 4 και μετά. Βλέπε <link
     linkend="functions.variable-arg-list">λίστες παραμέτρων μεταβλητού
     μήκους </link> και τις αναφορές συναρτήσεων για τις
     <function>func_num_args</function>,
     <function>func_get_arg</function>, και
     <function>func_get_args</function> για περισσότερες πληροφορίες. Ένα
     παρόμοιο αποτέλεσμα μπορεί να επιτευχθεί στην PHP 3 περνώντας ένας πίνακα
     παραμέτρων στη συνάρτηση:
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
]]>
     </programlisting>
    </informalexample>
   </para>
 
   <sect2 id="functions.arguments.by-reference">
    <title>Κάνοντας τις παραμέτρους να περνάνε με αναφορά</title>
 
    <simpara>
     Είναι προκαθορισμένο ότιοι παράμετροι των συναρτήσεων μεταβιβάζονται με τιμή (by value) (έτσι ώστε
     αν αλλάξετε την τιμή μιας παραμέτρου μέσα στη συνάρτηση, αυτή
     δεν αλλάξει έξω από τη συνάρτηση). Αν θέλετε να επιτρέψετε σε μια
     συνάρτηση να αλλάξει τις παραμέτρους της, θα πρέπει να τις περάσετε
     με αναφορά.
    </simpara>
    <para>
     Αν θέλετε μια παράμετρος συνάρτησης να την περνάτε πάντα με
     αναφορά, μπορείτε να βάλετε ως πρόθεμα ένα ampersand (&amp;) στο όνομα της
     παραμέτρου στόν ορισμό της συνάρτησης:
 
     <informalexample>
      <programlisting role="php">
<![CDATA[
function add_some_extra(&$string)
{
    $string .= 'and something extra.';
}
$str = 'This is a string, ';
add_some_extra($str);
echo $str;    // outputs 'This is a string, and something extra.'
]]>
      </programlisting>
     </informalexample>
    </para>
 
   </sect2>
 
   <sect2 id="functions.arguments.default">
    <title>Προκαθορισμένες τιμές συναρτήσεων</title>
 
    <para>
     ΜΙα συνάρτηση μπορεί να ορίσει προκαθορισμένες τιμές σαν τη C++ για βαθμωτές
     παραμέτρους ως ακολούθως:
 
     <informalexample>
      <programlisting role="php">
<![CDATA[
function makecoffee ($type = "cappuccino")
{
    return "Making a cup of $type.\n";
}
echo makecoffee ();
echo makecoffee ("espresso");
]]>
      </programlisting>
     </informalexample>
    </para>
 
    <para>
     Το αποτέλεσμα του παρακάτω κώδικα είναι:
 
     <screen>
Making a cup of cappuccino.
Making a cup of espresso.
     </screen>
    </para>
 
    <simpara>
     Η προκαθορισμένη τιμή πρέπει να είναι μια σταθερή έκφραση, όχι (για
     παράδειγμα) μια μεταβλητή ή ένα μέλος μιας κλάσης.
    </simpara>
    <para>
     Σημειώστε ότι όταν χρησιμοποιούμε προκαθορισμένες παραμέτρους, οποιεσδήποτε προκαθορισμένες θα πρέπει
     να είναι στη δεξιά μεριά από οποιεσδήποτε μη καθορισμένες παραμέτρους, διαφορετικά, τα πράγματα
     δε θα δουλέψουν όπως περιμένουμε. Θεωρείστε το ακόλουθο κομμάτι κώδικα:
 
     <informalexample>
      <programlisting role="php">
<![CDATA[
function makeyogurt ($type = "acidophilus", $flavour)
{
    return "Making a bowl of $type $flavour.\n";
}
 
echo makeyogurt ("raspberry");   // won't work as expected
]]>
      </programlisting>
     </informalexample>
    </para>
 
    <para>
     The output of the above example is:
 
     <screen>
Warning: Missing argument 2 in call to makeyogurt() in 
/usr/local/etc/httpd/htdocs/php3test/functest.html on line 41
Making a bowl of raspberry .
     </screen>
    </para>
 
    <para>
     Τώρα, συγκρίνετε το παραπάνω με αυτό:
 
     <informalexample>
      <programlisting role="php">
<![CDATA[
function makeyogurt ($flavour, $type = "acidophilus")
{
    return "Making a bowl of $type $flavour.\n";
}
 
echo makeyogurt ("raspberry");   // works as expected
]]>
      </programlisting>
     </informalexample>
    </para>
 
    <para>
     Το αποτέλεσμα του παραδείγματος είναι:
 
     <screen>
Making a bowl of acidophilus raspberry.
     </screen>
    </para>

   </sect2>

   <sect2 id="functions.variable-arg-list">
    <title>Λίστες μεταβλητού μήκους παραμέτρων</title>
	
    <simpara>
     Η PHP 4 υποστηρίζει λίστες παραμέτρων μεταβλητού μήκους στις
     συναρτήσεις που καθορίζονται από τον χρήστη. Αυτό είναι αρκετά εύκολο, χρησιμοποιώντας τις
     <function>func_num_args</function>,
     <function>func_get_arg</function>, και
     <function>func_get_args</function> συναρτήσεις.
    </simpara>

    <simpara>
     Καμια ιδιαίτερη σύνταξη δεν απαιτείται, και οι λίστες παραμέτρων μπορούν με σαφήνεια
     να παραχθούν με τους ορισμούς των συναρτήσεων και να συμπεριφέρονται
     κανονικά.
    </simpara>

   </sect2>

  </sect1>
 
  <sect1 id="functions.returning-values">
   <title>Επιστρέφοντας τιμές</title>
 
   <para>
    Οι τιμές επιστρέφονται χρησιμοποιώντας την προαιρετική δήλωση επιστροφής (return). Οποισδήποτε
    τύπος μπορεί να επιστραφεί, συμπεριλαμβανομένου λίστες και αντικείμενα. Αυτό προκαλεί τη
    συνάρτηση να σταματήσει και η εκτέλεση της αμέσως και να περάσει ο έλεγχος πίσω
    στη γραμμή από την οποία την καλέσαμε. Βλέπε <function>return</function>
    για περισσότερες πληροφορίες.
    <informalexample>
     <programlisting role="php">
<![CDATA[
function square ($num)
{
    return $num * $num;
}
echo square (4);   // outputs '16'.
]]>
     </programlisting>
    </informalexample>
   </para>
      
   <para>
    Δεν μπορούν να σας επιστραφούν πολλές τιμές από μια συνάρτηση, αλλά παρόμοια
    αποτελέσματα μπορούν να επιτευχθούν επιστρέφοντας μιας λίστα.
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
function small_numbers()
{
    return array (0, 1, 2);
}
list ($zero, $one, $two) = small_numbers();
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Για να επιστρέψετε μια αναφορά από μια συνάρτηση, πρέπει να χρησιμοποιήσετε
    τον τελεστή αναφοράς &amp; τόσο στη δήλωση της συνάρτησης όσο και
    όταν αναθέτε την επιστρεφόμενη τιμή σε μια μεταβλητή:
    <informalexample>
     <programlisting role="php">
<![CDATA[
function &returns_reference()
{
    return $someref;
}

$newref =& returns_reference();
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Για περισσότερες πληροφορίες στις αναφορές, παρακαλώ ελένξτε το <link
    linkend="language.references">Εξήγηση αναφορών</link>.
   </simpara>
  </sect1>
 
  <sect1 id="functions.old-syntax">
   <title><literal>old_function</literal></title>
 
   <simpara>
    Η δήλωση <literal>old_function</literal> σας επιτρέπει να
    δηλώσετε μια συνάρτηση χρησιμοποιώντας μια σύνταξη όμοι με την PHP/FI2 (εκτός του ότι
    πρέπει να αντικαταστήσετε την 'function' με την 'old_function'.
   </simpara>
   <simpara>
    Το χαρακτηριστικό αυτό πρέπει να χρησιμοποιείται μόνο
    με τον μετατροπέα της PHP/FI2->PHP 3.
   </simpara>
   <warning>
    <para>
     Οι συναρτήσεις που δηλώνονται ως <literal>old_function</literal> δεν μπορούν
     να κληθούν από τον εσωτερικό κώδικα της PHP. Ανάμεσα σε άλλα πράγματα, αυτό σημαίνει
     ότι δεν μπορείτε να τις χρησιμοποιήσετε σε συναρτήσεις όπως η
     <function>usort</function>, <function>array_walk</function>, και
     <function>register_shutdown_function</function>. Μπορείτε να
     ξεπεράσετε αυτόνο τον περιορισμό γράφοντας μια wrapper συνάρτηση (σε κανονική
     PHP 3 μορφή) που θα καλεί την <literal>old_function</literal>.
    </para>
   </warning>

  </sect1>

  <sect1 id="functions.variable-functions">
   <title>Μεταβλητές συναρτήσεις</title>

   <para>
    Η PHP υποστηρίζει την έννοια των μεταβλητών συναρτήσεων. Αυτό σημαίνει πως αν
    ένα όνομα μεταβλητής έχειπαρενθέσεις, η PHP θα ψάξει για μια
    συνάρτηση με το ίδιο όνομα που που της δίνει η μεταβλητή
    και θα προσπαθήσει να το εκτελέσει. Ανάμεσα στα άλλα πράγματα, αυτό μπορεί
    να χρησιμοποιηθεί για την υλοποίηση callbacks, πίνακες συναρτήσεων κα.
   </para>
   <para>
    Οι μεταβλητές συναρτήσεις δε θα δουλέψουν με δομές γλώσσας όπως
    οι <function>echo</function>, <function>print</function>,
    <function>unset</function>, <function>isset</function>,
    <function>empty</function>, <function>include</function>,
    <function>require</function> και άλλες παρόμοιες. Χρειάζετε να
    χρησιμοποιήσετε τη δική σας wrapper συνάρτηση για να χρησιμοποιήσετε οποιαδήποτε από τις δομές
    ως μεταβλητή συνάρτηση.
   </para>
   <para>
    <example>
     <title>Παράδειγμα μεταβλητής συνάρτησης</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
    echo "In foo()<br>\n";
}

function bar($arg = '')
{
    echo "In bar(); argument was '$arg'.<br>\n";
}

// This is a wrapper function around echo
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // This calls foo()

$func = 'bar';
$func('test');  // This calls bar()

$func = 'echoit';
$func('test');  // This calls echoit()
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Μπορείτε επίσης να καλέσετε τη μέθοδο ενός αντικειμένου χρησιμοποιώντας το χαρακτηριστικό των
    μεταβλητών συναρτήσεων.
    <example>
     <title>Παράδειγμα μεταβλητής μεθόδου</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Var()
    {
        $name = 'Bar';
        $this->$name(); // This calls the Bar() method
    }
    
    function Bar()
    {
        echo "This is Bar";
    }
}

$foo = new Foo();
$funcname = "Var";
$foo->$funcname();  // This calls $foo->Var()

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Δείτε επίσης <function>call_user_func</function>,
    <link linkend="language.variables.variable">
    variable variables</link> και <function>function_exists</function>.
   </para>
  </sect1>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
