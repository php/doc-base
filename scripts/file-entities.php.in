<?php
/*
# +----------------------------------------------------------------------+
# | PHP Version 4                                                        |
# +----------------------------------------------------------------------+
# | Copyright (c) 1997-2002 The PHP Group                                |
# +----------------------------------------------------------------------+
# | This source file is subject to version 2.02 of the PHP licience,     |
# | that is bundled with this package in the file LICENCE and is         |
# | avalible through the world wide web at                               |
# | http://www.php.net/license/2_02.txt.                                 |
# | If uou did not receive a copy of the PHP license and are unable to   |
# | obtain it through the world wide web, please send a note to          |
# | license@php.net so we can mail you a copy immediately                |
# +----------------------------------------------------------------------+
# | Authors:    Hartmut Holzgraefe <hholzgra@php.net>                    |
# |             Gabor Hojtsy <goba@php.net>                              |
# +----------------------------------------------------------------------+
# 
# $Id$
*/

/**
 *
 * Create phpdoc/entities/file-entities.ent with respect
 * to all the specialities needed:
 *
 *  . ZendAPI integration
 *  . CHM only appendix integration
 *  . Special install part (temporary)
 *  . Reserved constant part (temporary)
 *  . Translated language files with English ones as fallbacks
 *  . Global function index
 *
 * Also take in account, that if XSLT style sheets are used,
 * special file:/// prefixed path values are needed.
 *
 */

// Always flush output
ob_implicit_flush();
// This script runs for a long time
set_time_limit(0);

// ......:ARGUMENT PARSING:.....................................................

// Zend API integration info (either a path or "not found")
$zendapi = ("@ZENDAPI@" == "not found" ? FALSE : "@ZENDAPI@");

// when php complied on cygwin, the working path have to be /cygdrive..
// the below preg_replace have to be done only using binary php complied on MSVC.
// let's find if php was complied by cygwin:
$cygwin_complied = eregi("CYGWIN",php_uname()) ? true : false;
	
// The output directory, which we need to parse for windows specific
// things, and correct all problems is needed.
// Also use absolute path to have meaningful error messages
$out_dir = abs_path(strip_cygdrive("@WORKDIR@"));

// this path if used for saving the ent file:
$script_out_dir = $cygwin_complied ? "@WORKDIR@" : $out_dir;

// The source directory is passed in the 5th argument counting from backwards.
$srcdir = abs_path("@SRCDIR@");

// The translation dir is passed as the 6th argument, counting
// from the end of the argument list
$trans_dir = "$srcdir/@LANGDIR@";

// The original directory is in the base directory, and named "en"
$orig_dir = "$srcdir/en";

// ......:ENTITY CREATION:......................................................

// Put all the file entitites info $entities
$entities = array();
file_entities($orig_dir, $trans_dir, $orig_dir, $entities);

// Open file for appending and write out all entitities
$fp = fopen("$script_out_dir/entities/file-entities.ent", "w");
if (!$fp) {
    die("ERROR: Failed to open $script_out_dir/entities/file-entities.ent for writing\n");
}

echo "\ncreating entities/file-entities.ent...\n";

// File header
fputs($fp, "<!-- DON'T TOUCH - AUTOGENERATED BY file-entities.php -->\n\n");

// ZendAPI integration
if ($zendapi !== FALSE) {
    
    // Use absolute path to ZendAPI docs
    $zendapi = abs_path($zendapi);
    
    fputs(
        $fp,
        "<!-- begin ZendAPI integration -->\n" .
        entstr("% zend.defs", "$zendapi/Extending_Zend.ent") .
        entstr("zendapi.toc", "$zendapi/Extending_Zend.xml") .
        "%zend.defs;\n<!-- end ZendAPI integration -->\n\n"
    );
    echo " Zend part included\n";
} else {
    fputs(
        $fp,
        "<!-- ZendAPI not found -->\n" .
        entstr("zendapi.toc", "") . "\n"
    );
    echo " Zend part not found\n";
}

// Install part already splitted? [temporary]
if (file_exists("$trans_dir/chapters/install.xml")) {
    fputs(
        $fp,
        "<!-- old install.xml found in language dir -->\n" .
        entstr("chapters.install", "$trans_dir/chapters/install.xml") . "\n"
    );
    echo " Using install.xml in language dir\n";
} else {
    fputs(
        $fp,
        "<!-- old install.xml not found in language dir -->\n" .
        entstr("chapters.install", "$out_dir/installpart.xml") . "\n"
    );
    echo " Using the install part from installpart.xml\n";
}

// Reserved constants list is special [temporary]
fputs(
   $fp,
   "<!-- reserved constants in one central file -->\n" .
   entstr("appendices.reserved.constants", "$out_dir/reserved.constants.xml") . "\n"
);

// The global function index page is special
fputs(
   $fp,
   "<!-- global function index file -->\n" .
   entstr("global.function-index", "$out_dir/funcindex.xml") . "\n" .
   "<!-- all other files -->\n"
);

// Write out all other entities
foreach ($entities as $entity) {
    fputs($fp, $entity);
}
fclose($fp);

// Here is the end of the code
exit;

// ......:FUNCTION DECLARATIONS:................................................

/**
 * Generate absolute path from a relative path, taking accout
 * the current wokring directory.
 *
 * @param string $path Relative path
 * @return string Absolute path generated
 */
function abs_path($path) {

    // This is already an absolute path (begins with / or a drive letter)
    if (preg_match("!^(/|\\w:)!", $path)) { return $path; }

    // Get directory parts

    $absdir  = str_replace("\\", "/", getcwd());
    $absdirs = explode("/", preg_replace("!/scripts$!", "", $absdir));
    $dirs    = explode("/", $path);

    // Generate array representation of absolute path
    foreach ($dirs as $dir) {
        if (empty($dir) or $dir == ".") continue;
        else if ($dir == "..") array_pop($absdirs);
        else array_push($absdirs, $dir);
    }

    // Return with string
    return join("/", $absdirs);
}

/**
 * Create file entities, and put them into the array passed as the
 * last argument (passed by reference).
 *
 * @param string $work_dir English files' directory
 * @param string $trans_dir Translation's directory
 * @param string $orig_dir Original directory
 * @param array $entities Entities string array
 * @return boolean Success signal
 */
function file_entities($work_dir, $trans_dir, $orig_dir, &$entities) {

    // Skip the function directory not under "reference". That
    // folder is only kept for backward compatibility and only
    // in the English version of the docs.
    if (strpos($work_dir, "functions") && !preg_match("!reference/.*/functions!", $work_dir)) {
        return;
    }
    
    // Compute translated version's path
    $trans_path = str_replace($orig_dir, $trans_dir, $work_dir);
    
    // Try to open English working directory
    $dh = opendir($work_dir);
    if (!$dh) { return FALSE; }

    // If the working directory is a reference functions directory
    if (preg_match("!/reference/.*/functions$!", $work_dir)) {
        
        // Start new functions file with empty entity set
        $function_entities = array();
        $functions_file = "$work_dir.xml";

        // Get relative file path to original directory, and form an entity
        $functions_file_entity = str_replace("$orig_dir/", "", $work_dir);
        $functions_file_entity = fname2entname($functions_file_entity);
        $entities[] = entstr($functions_file_entity, $functions_file);
    }

    // While we can read that directory
    while (($file = readdir($dh)) !== FALSE) {

        // If file name begins with . skip it
        if ($file{0} == ".") { continue; }

        // If we found a directory, and it's name is not
        // CVS, recursively go into it, and generate entities
        if (is_dir($work_dir . "/" . $file)) {
            if ($file == "CVS") { continue; }
            file_entities($work_dir . "/" . $file, $trans_dir, $orig_dir, $entities);
        }

        // If the file name ends in ".xml"
        if (preg_match("!\\.xml$!", $file)) {
            
            // Get relative file name and get entity name for it
            $name = str_replace(
                "$orig_dir/",
                "",
                $work_dir . "/" . preg_replace("!\\.xml$!", "", $file)
            );
            $name = fname2entname($name);

            // If this is a functions directory, collect it into
            // the special $function_entities array
            if (isset($function_entities)) {
                $function_entities[] = "&$name;";
            }
            
            // Special treatment for function reference entities if splitted version available
            if (strstr($work_dir,"/functions")) {
                $splitfile = str_replace(".xml", "/reference.xml", $file);
                $splitpath = str_replace("/functions", "/reference", $trans_path) . "/" . $splitfile;
                if (file_exists($splitpath)) {
                  $entities[] = entstr($name, $splitpath);
                  continue;
                } 
                $splitpath = str_replace("/functions", "/reference", $trans_path) . "/" . $splitfile;
                if (file_exists($splitpath)) {
                  $entities[] = entstr($name, $splitpath);
                  continue;
                } 
            }
  
            // If we have a translated file, use it, otherwise fall back to English
            if (file_exists("$trans_path/$file")) {
                $path = "$trans_path/$file";
            } else {
                $path = "$work_dir/$file";
            }

            // Append to entities array
            $entities[] = entstr($name, $path);

        } // end of "if xml file"
    } // end of readdir loop
    
    // Close directory
    closedir($dh);

    // If we created a function entities list, write it out
    if (isset($function_entities)) {
        
        // Sort by name
        sort($function_entities);
        
        // Write out all entities with newlines
        $fp = fopen($functions_file, "w");
        foreach ($function_entities as $entity) {
            fputs($fp, "$entity\n");
        }
        fclose($fp);
    }

    // Find all files available in the translation but not in the original English tree
    if ($orig_dir != $trans_dir && file_exists($trans_path) && is_dir($trans_path)) {

        // Open translation path
        $dh = @opendir($trans_path);

        if ($dh) {

            while (($file = readdir($dh)) !== FALSE) {
                if ($file{0} =="." || $file == "CVS") { continue; }
                if (is_dir($trans_path."/".$file)) { continue; }
                
                // If this is an XML file
                if (preg_match("!\\.xml$!",$file)) {
                    
                    // Generate relative file path and entity name out of it
                    $name = str_replace(
                        "$orig_dir/",
                        "",
                        $work_dir . "/" . preg_replace("!\\.xml$!", "", $file)
                    );
                    $name = fname2entname($name);
                    
                    // If the file found is not in the English dir, append to entities list
                    if (!file_exists("$work_dir/$file")) {
                        $path = "$trans_path/$file";
                        $entities[] = entstr($name, $path);
                    }

                } // if this is an XML file end

            } // readdir iteration end
            closedir($dh);
        }
    }
    
} // end of funciton file_entities()

/**
 * Convert a file name (with path) to an entity name.
 *
 * Converts: _ => - and / => .
 *
 * @param string $fname File name
 * @return string Entity name
 */
function fname2entname($fname)
{
    return str_replace("_", "-", str_replace("/", ".", $fname));
}

/**
 * Return entity string with the given entityname and filename.
 * 
 * @param string $entname Entity name
 * @param string $filename Name of file
 * @return string Entity declaration string
 */
function entstr($entname, $filename)
{
    // If we have no file, than this is not a system entity
    if ($filename == "") {
        return sprintf("<!ENTITY %-40s        ''>\n", $entname);
    } else {
        return sprintf("<!ENTITY %-40s SYSTEM '%s'>\n", $entname, strip_cygdrive($filename));
    }
}

/**
 * Return windows style path for cygwin.
 * 
 * @param string $path Orginal path
 */
function strip_cygdrive($path){
	return preg_replace("!^/cygdrive/(\\w)/!", "\\1:/", $path);
}
?>
